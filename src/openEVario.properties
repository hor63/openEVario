 
# openEVario.cfg
#
# Configuration of openEVario
#
# Created on: Jan 21, 2018
#     Author: hor
#
#  This file is part of openEVario, an electronic variometer for glider planes
#  Copyright (C) 2018  Kai Horstmann
#
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  any later version.
#
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#
#  You should have received a copy of the GNU General Public License along
#  with this program; if not, write to the Free Software Foundation, Inc.,
#  51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
#

# Base idle cycle of predictions of the Kalman filter in absence of measurement updates in Milliseconds
# Default 20 (ms)
idlePredictionCycle = 20

# Maximum time between the last prediction update and a measurement update.
# If a measurement update is performed, and the last prediction is larger
# than this value another prediction update is performed before the measurement update is performed.
# Default 5 ms
maxTimeBetweenPredictionAndMeasurementUpdate = 5  

# Terminate the program when a driver cannot be loaded, 
# or the driver entry point cannot be found,
# or the driver is incompatible
# Values: yes, no
# Default: yes
terminateOnDriverLoadError = no

# List of shared libraries implementing the sensor drivers
# List of shared libraries
driverSharedLibs = "openEVIGCReader-0.dll", "openEVIGCReader.so", "openEVBMXSensorBoard-0.dll", "openEVBMXSensorBoard.so" , "openEVNmeaGPS-0.dll", "openEVNmeaGPS.dll"

#-----------------------------------------
# I/O-Ports. ("port" in the following)
#-----------------------------------------
# Ports are defined in the structure "IOPorts".
# There is one entry per port. Each port is a structure.
# The fields in a port structure differ, based on the port type.
# Common fields for all or at least most port types: 
#   type: Mandatory; port types are either built-in, or additional ones from external driver libs.
#   device: This is the name of the device in the system like '/dev/ttyS0' or
#     'COM8' or '\\.\COM8' (Windows) (Note that '\' characters must be masked, in this case results in '\\\\.\\COM8'!)
#     if the parameter is omitted the port name is assumed to be the device name.
#     Some port types (like network connections) do not use the device field.
#	blocking: yes/no on/off true/false (default yes). If the property is used depends on the port type.
#
# The built-in port types are described here.
# Built-in drivers are: serial, TCPClient, UDP, I2C
# Description of additional parameters for each driver type. Parameters not marked as mandatory are optional:
#
# type = serial # UART or virtual serial ports.
#	device: (mandatory) See above.
#	baud: Flow rate. Supported are: 1200, 2400, 4800, 9600, 19200, 38400, 57600, 115200, default: keep the current setting.
#		MS-Dos MODE style abbreviations are allowed: 11 (110), 15 (150), 30 (300), 60 (600), 12 (1200), 24 (2400),
#           48 (4800), 96 (9600), 192 (19200), 384 (38400), 576 (57600), 1152 (115200).
#		Under Linux these higher rates may be recognized: 230400, 460800, 500000, 576000, 921600, 1000000
#		This is version and system dependent. If your serial device driver supports it is still a complete different story.
#	bits: Number of data bits. 8 or 7 (5 or 6 are not supported), default: keep the current setting.
#	parity: Parity.  n (none), o (odd), e (even). If odd or even parity is set the parity is sent, and checked on receiving.
#     When a framing or parity error is detected the character becomes \0. Default: keep the current setting.
#	stopbits: 1 or 2, default: keep the current setting.
#	handshake: Flow control. Default: keep the current setting.
#		none: No flow control
#		rtscts: RTC/CTS hardware handshake, 
#		xonxoff: XOn/XOff software handshake. XOn and XOff characters (021/DC1 and 023/DC3 are not available for data).
#	blocking (see above) is recognized.
#	
#	All the optional parameters can be omitted for virtual serial ports (like USB or Bluetooth) 
#	where they are most likely ignored anyway or may lead to strange results.
#	However upon opening the port will be set to raw mode (Character-wise reading, no processing of data...)
#
# type = TCPClient # TCP/IP client. Actively establishes a connection to a server.  Common parameter 'device' is un-used here.
#	host: (mandatory) Can be numeric or symbolic. IPV4 and IPV6 are supported.
#	port: (mandatory) Numeric or symbolic port numbers (/etc/services) are supported.
#	blocking (see above) is recognized.
# 
# type = UDP # UDP bi-directional connection-less message/datagram oriented connection. In one word: UDP.
#	peerAddress: IP address of the peer computer. Can be numeric or symbolic. IP V4 and V6 are both supported.
#		If omitted you cannot send a message to the peer via the standard interface.
#		However you still can obtain the socket handle, and use [sendto](https://man7.org/linux/man-pages/man2/sendto.2.html) yourself.
#	localAddress: The local address on which the connection will listen to datagrams from the peer.
#		This can be one interface address, or the default local address, or the wildcard address (0.0.0.0, or the IP V6 equivalent).
#		If you omit the parameter, or use the any address the port will receive messages from any host which sends to the specified port.
#	peerPort: Port on which the peer listens. If not specified you cannot send with the class interface.
#		However you still can obtain the socket handle, and use [sendto](https://man7.org/linux/man-pages/man2/sendto.2.html) yourself.
#	localPort: This is the port on which the socket receives datagrams from peer(s).
#		If you do not specify it or set it to 0 a dynamic port number will be assigned when you send data to a peer for the first time.
#		You *must* specify the local port in order to be able to receive data from the peer.
#	blocking (see above) is recognized.
#		
IOPorts = {
	GPSPort = {
		type = serial
        device = "/dev/ttyS13"
#		baud = 19200
#		bits = 8
#		parity = n
#		stopbits = 1
#		handshake = none
	}
	
	BMX160SensorBoardPort = {
		type = TCPClient
		host = "192.168.203.2"
		port = 19463
	}
	BMX160SensorBoardUDPPort = {
		type = UDP
		peerAddress = "192.168.203.2"
		localAddress = "192.168.203.1"
		peerPort = 19463
		localPort = 19463
	}
}

#-----------------------------------------
# List of named driver instances.
#-----------------------------------------
# Each driver instance listed here must must define a structure. They are located below
# drivers = "BMX160SensorBoard0", "GPS0"
drivers = "GPS0"

#-----------------------------------------
# Driver instances
#-----------------------------------------
# One parameter for each driver instance is mandatory: "driver".
# The value of "driver" must match one of the available drivers implemented by one of the driver libraries.
# All other parameters are specific to the driver and driver library. Please consult the driver documentation.

IGCReader0 = {
	driver = IGCReader
	file = xxx.igc
	
	# Run the measurement updates and Kalmen filter updates inernally single-threaded. 
	# Use for debugging purposes only. This option means that the driver will never return from the the driver start() call.
	# The driver will instead terminate the program when the entire IGC file is processed.
	#
	# Default is "yes"
	runSingleThreadDebug = yes
	
	# Run the driver simulation in real time
	# This parameter is only used when runSingleThreadDebug is true.
	# If the parameter is false the internal loop will be run at full speed without breaks to achieve (near) real time.
	#
	# Default is "false"
	runInRealTime = false 
	}
	

BMX160SensorBoard0 = {
	driver = "BMX160SensorBoard"
	
	# Communications port; mandatory.
	# Port must be defined in the "IOPorts" section. It must be a datagram (i.e. UDP) port.
	# The recommended branch of the sensor bord firmware supports UDP. 
	portName = "BMX160SensorBoardUDPPort"
	
	# Timeout between occurrence of an error, and next attempt to re-open the port, and resume operations.
	# in full seconds
	# Optional. Default 10 (sec)
	errorTimeout = 10
	
	# Maximum number of re-tries to re-establish operations with the sensor board before ceasing operations.
	# When at least one message is successfully received the re-try counter is reset.
	# Default 0, i.e. no limit of re-tries
	errorMaxNumRetries = 0
	
	# Location of the sensor driver config file.
	# Here are primarily calibration data stored like magnetometer bias/deviation
	# Preferably the path should be the same as this config file.
	calibrationDataFile = BMX160SensorBoardCalib.properties
	
	# Cycle time how often the calibration data are written back into the calibration data file in seconds.
	# 0 means the calibration data file is not updated.
	# Default: 0, i.e. the calibration data file is never updated.
	calibrationDataUpdateCycle = 120
	}
	
GPS0 = {
    driver = "NmeaGPS"
    
    # Communications port; mandatory.
    # Port must be defined in the "IOPorts" section. It must be a stream port, i.e a TCP or serial port.
    portName = "GPSPort"

    # Timeout between occurrence of an error, and next attempt to re-open the port, and resume operations.
    # in full seconds
    # Optional. Default 10 (sec)
    errorTimeout = 10
    
    # Maximum number of re-tries to re-establish operations with the sensor board before ceasing operations.
    # When at least one message is successfully received the re-try counter is reset.
    # Default 0, i.e. no limit of re-tries
    errorMaxNumRetries = 0
    }
